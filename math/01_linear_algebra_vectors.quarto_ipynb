{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"01 Linear Algebra - Vectors\"\n",
        "format:\n",
        "  html:\n",
        "    css: homework-styles.css\n",
        "---\n",
        "\n",
        "\n",
        "<script src=\"homework-scripts.js\"></script>\n",
        "\n",
        "![image.png](../background_photos/math_01_shinararutun.jpg)\n",
        "[’¨’∏÷Ç’Ω’°’∂’Ø’°÷Ä’´ ’∞’≤’∏÷Ç’¥’®](https://unsplash.com/photos/black-and-yellow-crane-near-building-during-daytime-JcRhkLqvICA), ’Ä’•’≤’´’∂’°’Ø’ù [Suren Sargsyan](https://unsplash.com/@s_u_ren)\n",
        "      \n",
        "\n",
        "# üìö ’Ü’µ’∏÷Ç’©’®\n",
        "\n",
        "- [üìö ‘±’¥’¢’∏’≤’ª’°’Ø’°’∂ ’∂’µ’∏÷Ç’©’®](01_vectors_linear_algebra.qmd)\n",
        "- [üì∫ ’é’•’Ø’ø’∏÷Ä’∂’•÷Ä, ’Ω’Ø’°’¨’µ’°÷Ä ’°÷Ä’ø’°’§÷Ä’µ’°’¨, ’æ’•’Ø’ø’∏÷Ä’´ ’∂’∏÷Ä’¥](https://www.youtube.com/watch?v=-VPo9D_E6FQ), [üéûÔ∏è ’ç’¨’°’µ’§’•÷Ä](Lectures/L01_Vectors.pdf)\n",
        "- [üì∫ ‘±’∂’Ø’µ’∏÷Ç’∂, ’Ø’∏’Ω’´’∂’∏÷Ç’Ω’°’µ’´’∂ ’∂’¥’°’∂’∏÷Ç’©’µ’∏÷Ç’∂, ’£’Æ’°’µ’´’∂ ’ø’°÷Ä’°’Æ’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä](https://www.youtube.com/watch?v=kh10WTvYTR0), [üéûÔ∏è ’ç’¨’°’µ’§’•÷Ä](Lectures/L02_Angles__Vector_Spaces__Matrices.pdf)\n",
        "- [üõ†Ô∏èüì∫ ‘±’∂’Ø’µ’∏÷Ç’∂, ’∂’∏÷Ä’¥, ’æ’•’Ø’ø’∏÷Ä’°’Ø’°’∂ (’•’∂’©’°)’ø’°÷Ä’°’Æ’∏÷Ç’©’µ’∏÷Ç’∂](https://www.youtube.com/watch?v=bLQJIKmkqmE), [üõ†Ô∏èüóÇÔ∏è ‘≥’∏÷Ä’Æ’∂’°’Ø’°’∂’´ PDF-’®](Homeworks/hw_01_vectors.pdf)\n",
        "  \n",
        "\n",
        "üìö ’è’°’∂’® ’Ø’°÷Ä’§’∏÷Ç’¥ ’•’∂÷Ñ’ù\n",
        "\n",
        "**’é’•’Ø’ø’∏÷Ä’∂’•÷Ä, ’Ω’Ø’°’¨’µ’°÷Ä ’°÷Ä’ø’°’§÷Ä’µ’°’¨, ’æ’•’Ø’ø’∏÷Ä’´ ’∂’∏÷Ä’¥**\n",
        "\n",
        "- [Poole](bibliography/Poole - Linear Algebra-1-400.pdf), 2-12 ’ß’ª’•÷Ä’® (’æ’•’Ø’ø’∏÷Ä’∂’•÷Ä)\n",
        "- [Johnston](bibliography/Nathaniel Johnston - Introduction to Linear and Matrix Algebra-Springer (2021).pdf), 10-14 ’ß’ª’•÷Ä’® (’∂’∏÷Ä’¥)\n",
        "\n",
        "÷á ’§’´’ø’∏÷Ç’¥ 3b1b-’´ 1-’´’∂ [’ø’•’Ω’°’§’°’Ω’®](https://youtu.be/fNk_zzaMoSs) ’£’Æ’°’µ’´’∂ ’∞’°’∂÷Ä’°’∞’°’∑’æ’´÷Å(’∂’∏÷Ç’µ’∂’® [’∞’°’µ’•÷Ä’•’∂](https://youtu.be/7-r7Z2iH0Ps))\n",
        "\n",
        "\n",
        "**‘±’∂’Ø’µ’∏÷Ç’∂, ’Ø’∏’Ω’´’∂’∏÷Ç’Ω’°’µ’´’∂ ’∂’¥’°’∂’∏÷Ç’©’µ’∏÷Ç’∂, ’£’Æ’°’µ’´’∂ ’ø’°÷Ä’°’Æ’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä**\n",
        "\n",
        "- [Johnston](bibliography/Nathaniel Johnston - Introduction to Linear and Matrix Algebra-Springer (2021).pdf), 15-19 ’ß’ª’•÷Ä’® (‘ø’∏’∑’´-’á’æ’°÷Ä÷Å, ’°’∂’Ø’µ’∏÷Ç’∂)\n",
        "- [Poole](bibliography/Poole - Linear Algebra-1-400.pdf), 26-28 ’ß’ª’•÷Ä’® (’ä’µ’∏÷Ç’©’°’£’∏÷Ä’°’Ω’´ ’©’•’∏÷Ä’•’¥, ’∫÷Ä’∏’µ’•’Ø÷Å’´’°)\n",
        "- [Johnston](bibliography/Nathaniel Johnston - Introduction to Linear and Matrix Algebra-Springer (2021).pdf), 121-124 ’ß’ª’•÷Ä’® (’£’Æ’°’µ’´’∂ ’ø’°÷Ä’°’Æ’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä)\n",
        "÷á ÷Å’°’∂’Ø’∏÷Ç’©’µ’°’∂ ’§’•’∫÷Ñ’∏÷Ç’¥ ’§’´’ø’∏÷Ç’¥ StatQuest-’´ ’ø’•’Ω’°’§’°’Ω’® (https://youtu.be/e9U0QAFbfLI) ’Ø’∏’Ω’´’∂’∏÷Ç’Ω’°’µ’´’∂ ’∂’¥’°’∂’∏÷Ç’©’µ’°’∂ ’¥’°’Ω’´’∂\n",
        "\n",
        "‘≤’∏’¨’∏÷Ä ’£÷Ä÷Ñ’•÷Ä’® [’°’µ’Ω’ø’•’≤](https://drive.google.com/drive/folders/14ib_UZSDQ4UPW6XgncURhhbtWLs3-qV3?usp=drive_link) ’•’∂÷â\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# üè° ’è’∂’°’µ’´’∂\n",
        "\n",
        "::: {.callout-note collapse=\"false\"}\n",
        "1. ‚ùó‚ùó‚ùó DON'T CHECK THE SOLUTIONS BEFORE TRYING TO DO THE HOMEWORK BY YOURSELF‚ùó‚ùó‚ùó\n",
        "2. Please don't hesitate to ask questions, never forget about the üçäkaralyoküçä principle!\n",
        "3. The harder the problem is, the more üßÄcheesesüßÄ it has.\n",
        "4. Problems with üéÅ are just extra bonuses. It would be good to try to solve them, but also it's not the highest priority task.\n",
        "5. If the problem involve many boring calculations, feel free to skip them - important part is understanding the concepts.\n",
        "6. Submit your solutions [here](https://forms.gle/CFEvNqFiTSsDLiFc6) (even if it's unfinished)\n",
        ":::\n",
        "\n",
        "\n",
        "## Vector Operations\n",
        "\n",
        "### 01 RGB color mixing with vectors {data-difficulty=\"1\"}\n",
        "\n",
        "::: {.callout-tip collapse=\"true\" appearance=\"minimal\"}\n",
        "#### Context\n",
        "In computer graphics and image processing, colors can be represented as RGB vectors where each component (Red, Green, Blue) ranges from 0 to 255. Vector operations on these RGB values correspond to color mixing and transformations.\n",
        ":::\n",
        "\n",
        "Consider these RGB color vectors:\n",
        "\n",
        "- Red: $\\vec{r} = (255, 0, 0)$\n",
        "- Cyan: $\\vec{c} = (0, 255, 255)$\n",
        "\n",
        "1. Calculate what color you get by adding red and cyan: $\\vec{r} + \\vec{c}$.\n",
        "2. Find the \"average\" color between red and cyan: $\\frac{1}{2}(\\vec{r} + \\vec{c})$.\n",
        "3. Use a [color picker](https://share.google/yadDErXuKGKRwIHnq) to verify your answers from parts (1) and (2). What colors do you actually see?\n",
        "\n",
        "### 02 Dot product {data-difficulty=\"1\"}\n",
        "A translation office translated $a = [24, 17, 9, 13]$ documents from English,\n",
        "French, German and Russian, respectively. For each of those languages, it takes about\n",
        "$b = [5, 10, 11, 7]$ minutes to translate one page.\n",
        "How much time did they spend translating in total? How much did each of the translators\n",
        "spend on average if there are 4 translators in the office? Write an expression for this amount\n",
        "in terms of the vectors $a$ and $b$.\n",
        "\n",
        "\n",
        "### 03 Feature vector normalization {data-difficulty=\"2\"}\n",
        "\n",
        "::: {.callout-note collapse=\"true\" appearance=\"minimal\"}\n",
        "#### Context\n",
        "In machine learning, we often work with data that has very different scales - like comparing a person's age (around 20-80) with their salary (around 20,000-100,000). Without normalization (bringing all the values to a similar scale (e.g. having length of 1)), algorithms might think salary is much more important just because the numbers are bigger. Normalizing vectors to unit length helps ensure all features are treated equally.\n",
        ":::\n",
        "\n",
        "A customer is represented by the vector $\\vec{v} = (25, 50000, 3)$ where components represent [age, income in $, number of purchases].\n",
        "\n",
        "1. Calculate the Euclidean norm (magnitude) $||\\vec{v}||_2$\n",
        "2. Find the unit vector $\\hat{v} = \\frac{\\vec{v}}{||\\vec{v}||_2}$\n",
        "3. Verify that $||\\hat{v}||_2 = 1$\n",
        "\n",
        "*Note:* No need to carry out the calculations explicitly.\n",
        "\n",
        "\n",
        "\n",
        "### 04 Triangle inequality {data-difficulty=\"2\"}\n",
        "For vectors $\\vec{u} = (3, 4)$ and $\\vec{v} = (5, -12)$:\n",
        "\n",
        "1. Calculate $||\\vec{u}||$, $||\\vec{v}||$, and $||\\vec{u} + \\vec{v}||$\n",
        "2. Verify the triangle inequality: $||\\vec{u} + \\vec{v}|| \\leq ||\\vec{u}|| + ||\\vec{v}||$\n",
        "3. When does equality hold in the triangle inequality?\n",
        "\n",
        "\n",
        "### 05 Model selection with regularization {data-difficulty=\"2\"}\n",
        "::: {.callout-important collapse=\"true\" appearance=\"minimal\"}\n",
        "#### Context\n",
        "In machine learning, we constantly face a tradeoff: should we use a complex model that fits our training data very well, or a simpler model that captures the general pattern? This is where **regularization** comes in.\n",
        "\n",
        "Imagine you're Netflix trying to predict movie ratings. You could create an extremely complex formula with thousands of parameters that perfectly predicts every rating in your training data. But when a new user comes along, your model might fail spectacularly - it memorized the training data instead of learning the underlying patterns. This is called **overfitting**. ([Kargin example](https://www.youtube.com/watch?v=723rlQAhXqc))\n",
        "\n",
        "**Regularization** prevents overfitting by adding a penalty for model complexity to our optimization goal:\n",
        "\n",
        "$$\\text{Total Error} = \\text{Prediction Error} + \\lambda \\cdot \\text{Complexity Penalty}$$\n",
        "\n",
        "where $\\lambda$ controls how much we penalize complexity (having large parameter values).\n",
        "\n",
        "The two most common regularization methods use different norms to measure complexity:\n",
        "\n",
        "- **L1 Regularization (Lasso)**: Uses the sum of absolute values\n",
        "   $$\\text{L1 penalty} = \\lambda \\sum_{i=1}^{n} |w_i|$$\n",
        "   \n",
        "- **L2 Regularization (Ridge)**: Uses the sum of squares\n",
        "   $$\\text{L2 penalty} = \\lambda \\sum_{i=1}^{n} w_i^2$$\n",
        "\n",
        "**Real-world example:** Suppose you're predicting house prices using features like size, location, age, etc. Without regularization, your model might learn that \"houses with exactly 2,347 sq ft, built in 1987, with 3.5 bathrooms, facing north-northeast, with blue doors\" sell for $523,456. With regularization, it learns more general rules like \"larger houses in good neighborhoods cost more.\"\n",
        ":::\n",
        "\n",
        "’é’Ω’ø’°’∞ ’π’•’¥ ’∏÷Ä ’¨’°’æ ’•’¥ ’±÷á’°’Ø’•÷Ä’∫’•’¨ (’∞’°’ø’Ø’°’∫’•’Ω) ’ß’Ω ’≠’∂’§’´÷Ä’® , ’•’©’• ’∞’°÷Ä÷Å’•÷Ä ’¨’´’∂’•’∂’ù ’≠’°’¢’°÷Ä ’°÷Ä’•÷Ñ÷â\n",
        "\n",
        "\n",
        "You're comparing two models that predict house prices:\n",
        "\n",
        "- Model A: Complex formula with weights (coefficients) $\\vec{w_A} = (10, -8, 4)$ (this can correspond to equation ($10x^2 - 8x + 4$ (quadratic))) and prediction error = 100\n",
        "- Model B: Simpler formula with weights $\\vec{w_B} = (0.1, -3, 1)$ $(0.1x^2 - 3x + 1)$ (almost just a linear function) and prediction error = 120\n",
        "\n",
        "Model B makes slightly worse predictions, but which model is better when considering both error and simplicity?\n",
        "\n",
        "a) **L1 Regularization (Œª = 0.5):** Calculate the total error for each model\n",
        "   - Model A: $\\text{Error} + \\lambda \\cdot ||\\vec{w_A}||_1 = ?$\n",
        "   - Model B: $\\text{Error} + \\lambda \\cdot ||\\vec{w_B}||_1 = ?$\n",
        "\n",
        "b) **L2 Regularization (Œª = 0.5):** Calculate the total error for each model\n",
        "   - Model A: $\\text{Error} + \\lambda \\cdot ||\\vec{w_A}||_2^2 = ?$\n",
        "   - Model B: $\\text{Error} + \\lambda \\cdot ||\\vec{w_B}||_2^2 = ?$\n",
        "\n",
        "c) **Model Selection:** Which model would you choose under each regularization method? How does the choice of $\\lambda$ affect your decision?\n",
        "d) **Practical Insight:** In production systems, why might we prefer a model with slightly worse accuracy but much simpler weights?\n",
        "\n",
        "\n",
        "\n",
        "### 06 k-Nearest Neighbors Classification {data-difficulty=\"3\"}\n",
        "\n",
        "\n",
        "‘ø÷Å’æ’°’Æ ’Ø’£’ø’∂’•÷Ñ [csv ÷Ü’°’µ’¨](assets/knn.csv) ’•÷Ä’•÷Ñ ’Ω’µ’∏÷Ç’∂’∏’æ’ù feature_1, feature_2, label÷â \n",
        "‘ø’°÷Ä’∏’≤ ’•÷Ñ ’∫’°’ø’Ø’•÷Ä’°÷Å’∂’•’¨  ’∏÷Ä feature_1-’® ’´÷Ä’°’∂’´÷Å ’∂’•÷Ä’Ø’°’µ’°÷Å’∂’∏÷Ç’¥ ’° ’Æ’°’≤’Ø’´ ’¢’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®, feature_2-’®’ù ’¨’°’µ’∂’∏÷Ç’©’µ’∏÷Ç’∂’® ’∏÷Ç label (’∫’´’ø’°’Ø’®)  ’∂’•÷Ä’Ø’°’µ’°÷Å’∂’∏÷Ç’¥ ’° ’©’• 4 ’Æ’°’≤’Ø’´ ’ø’•’Ω’°’Ø’∂’•÷Ä’´÷Å (0,1,2,3) ’∏÷Ä ’¥’•’Ø’∂ ’°÷â\n",
        "\n",
        " ’ä’•’ø÷Ñ ’° ’Ω’ø’•’≤’Æ’•’¨ ’¥’∏’§’•’¨ (’°’¨’£’∏÷Ä’´’©’¥) ’∏÷Ä’® ’Ω’ø’°’∂’°’¨’∏’æ feature_1, feature_2 ’°÷Ä’™’•÷Ñ’∂’•÷Ä’® ’Ø’£’∏÷Ç’∑’°’Ø’´ ’Æ’°’≤’Ø’´ ’ø’•’Ω’°’Ø’®÷â \n",
        "\n",
        "’Ä’•’ø÷á’µ’°’¨ ’Ø’•÷Ä’∫’∏’æ’ù ’∂’∏÷Ä ’Æ’°’≤’Ø’´ ’∞’°’¥’°÷Ä ’£’ø’∂’•’¨ K ’∞’°’ø ’°’¥’•’∂’°’¥’∏’ø’´’Ø ’Æ’°’≤’´’Ø’∂’•÷Ä’® ’¥’•÷Ä ’∏÷Ç’∂’•÷Å’°’Æ ’ø’æ’µ’°’¨’∂’•÷Ä’´÷Å ’∏÷Ç ’∂’°’µ’•’¨ ’©’• ’ß’§ k ’∞’°÷Ä÷á’°’∂’∂’•÷Ä’´÷Å ’∏÷Ä ’ø’•’Ω’°’Ø’´ ’Æ’°’≤’´’Ø’∂ ’° ’£’•÷Ä’°’Ø’∑’º’∏÷Ç’¥’ù ’∏÷Ç ’§’° ÷Ö’£’ø’°’£’∏÷Ä’Æ’•’¨ ’∏÷Ä’∫’•’Ω ’£’∏÷Ç’∑’°’Ø’∏÷Ç’©’µ’∏÷Ç’∂, \n",
        "\n",
        "’Ä’•’º’°’æ’∏÷Ä’∏÷Ç’©’µ’∏÷Ç’∂ ’∏÷Ä’∫’•’Ω ÷Ö’£’ø’°’£’∏÷Ä’Æ’•÷Ñ ’¥’´ ’§’•’∫÷Ñ’∏÷Ç’¥ L1-’® (Manhattan), ’¥’´ ’§’•’∫÷Ñ’∏÷Ç’¥ L2-’® (Euclidean): K-’´ ’∞’°’¥’°÷Ä ’ß’¨ ’ø’°÷Ä’¢’•÷Ä ’°÷Ä’™’•÷Ñ’∂’•÷Ä ’¢’¶’¢’°÷Å’•÷Ñ’ù 2,3, 5, 10 .\n",
        "\n",
        "‘π’•’©÷á ’∞’°’æ’•’¨’µ’°’¨ ’∂’∑’∏÷Ç’¥’∂’•÷Ä\n",
        "1. ‘±’¨’£’∏÷Ä’´’¥’©’´ ’°’∂’∏÷Ç’∂’∂ ’° K Nearest Neighbors ’∏÷Ç ’¶’∏÷Ç’ø \"’°’Ω’° ’´’∂’± ’∏’æ÷Ñ’•÷Ä ’•’∂ ÷Ñ’∏ ’®’∂’Ø’•÷Ä’∂’•÷Ä’®, ’•’Ω ’Ø’°’Ω’•’¥ ’∏’æ ’•’Ω ’§’∏÷Ç\" ’Ω’Ø’¶’¢’∏÷Ç’¥÷Ñ’∏’æ ’° ’°’∑’≠’°’ø’∏÷Ç’¥, ’∫÷Ä’°’Ø’ø’´’Ø’°’µ’∏÷Ç’¥ ’∞’°’¥’°÷Ä’µ’° ’•÷Ä’¢’•÷Ñ ’π’´ ÷Ö’£’ø’°’£’∏÷Ä’Æ’æ’∏÷Ç’¥ ’¢’°’µ÷Å ’ø’∂’°’µ’´’∂’´ ’∞’°’¥’°÷Ä ’Ø’°÷Ä’° ’∞’°’æ’•’Ω ’¨’´’∂’´ \n",
        "2. ’ä’°’ø’≥’°’º’∂’•÷Ä’´÷Å ’¥’•’Ø’® ’©’• ’´’∂’π’´ ’π’´ ÷Ö’£’ø’°’£’∏÷Ä’Æ’æ’∏÷Ç’¥ ’§’° \"’â’°÷É’∏’≤’°’Ø’°’∂’∏÷Ç’©’µ’°’∂ ’°’∂’•’Æ÷Ñ’∂\" ’° (Curse of dimenionality), ’∑’°’ø ’∞’°’æ’•’Ω ’ß÷Ü’•’Ø’ø ’° ’®’Ω’ø ’∏÷Ä’´ ’•÷Ä’¢ ’£’∏÷Ä’Æ ’•’∂÷Ñ ’∏÷Ç’∂’•’∂’∏÷Ç’¥ ’¢’°÷Ä’±÷Ä ’π’°÷É’°’∂’´ ’ø’°÷Ä’°’Æ’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´ ’∞’•’ø, ’ø’æ’µ’°’¨’∂’•÷Ä’® ’∞’´’¥’∂’°’Ø’°’∂’∏÷Ç’¥ ’´÷Ä’°÷Ä’´÷Å ’∞’°’¥’°÷Ä’µ’° ’∞’°’æ’°’Ω’°÷Ä’°’∞’•’º ’•’∂ ’§’°’º’∂’∏÷Ç’¥ ’∏÷Ç ’°’∂’Ø’µ’∏÷Ç’∂’∂’•÷Ä’∏÷Ç’¥ ’•’∂ ’Ø’∏÷Ç’ø’°’Ø’æ’∏÷Ç’¥ (’°’µ’¨ ’Ø’•÷Ä’∫ ’°’Ω’°’Æ’ù ’•’©’• ’¢’°÷Ä’±÷Ä’°’π’°÷É ’∂’°÷Ä’´’∂’ª’® ’Ø’¨’∫’•’∂÷Ñ’ù ’ø’°’Ø’® ’¢’°’∂ ’π’´ ’¥’∂’°)÷â ‘±’≤’¢’µ’∏÷Ç÷Ä (https://slds-lmu.github.io/i2ml/chapters/14_cod/)\n",
        "\n",
        "## Dot Products and Angles Between Vectors\n",
        "\n",
        "### 07 Finding perpendicular vectors {data-difficulty=\"1\"}\n",
        "\n",
        "\n",
        "Given the vector $\\vec{v} = (2, 3)$:\n",
        "\n",
        "1. Find a non-zero vector $\\vec{w} = (x, y)$ such that $\\vec{v}$ and $\\vec{w}$ are perpendicular.\n",
        "2. Verify that your chosen vector $\\vec{w}$ satisfies $\\vec{v} \\cdot \\vec{w} = 0$.\n",
        "3. Find a unit vector in the direction of $\\vec{w}$ by computing $\\frac{\\vec{w}}{||\\vec{w}||}$.\n",
        "4. Explain why there are infinitely many vectors perpendicular to $\\vec{v}$ and describe the general form of all such vectors.\n",
        "\n",
        "\n",
        "### 08: Word embeddings similarity {data-difficulty=\"3\"}\n",
        "::: {.callout-important collapse=\"true\" appearance=\"minimal\"}\n",
        "#### Context\n",
        "Computers understand numbers, not words. To make sense of text, we convert words into vectors in a high-dimensional space, called **word embeddings**. In this space, words with similar meanings are located close to each other. For example, \"king\" and \"queen\" are closer than \"king\" and \"car\".\n",
        ":::\n"
      ],
      "id": "9fa7a99c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# install gensim if you haven't already (you can also do it without `uv`, but why would you? uv is fantastic)\n",
        "# !uv pip install gensim\n",
        "\n",
        "import gensim.downloader as api\n",
        "\n",
        "# this might take a few minutes first time\n",
        "model_name = \"glove-twitter-25\" # smaller model \n",
        "\n",
        "# If you're willing to wait a bit longer for a better model, uncomment line below:\n",
        "# model_name = \"word2vec-google-news-300\"  # 1.5 gb model\n",
        "\n",
        "model = api.load(model_name)  # 300-dimensional vectors\n",
        "\n",
        "print(\"Model loaded successfully!\")\n",
        "\n",
        "# to get vector for a word we just get it like from a dictionary\n",
        "word = \"cheese\"\n",
        "if word in model:\n",
        "    vector = model[word]\n",
        "    print(f\"Vector for '{word}' has shape: {vector.shape}\")\n",
        "    print(f\"First 10 dimensions: {vector[:10]}\")\n",
        "else:\n",
        "    print(f\"'{word}' not found in vocabulary\")"
      ],
      "id": "92bb5012",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Familiarize yourself with the code above. It loads a pre-trained word embedding model and retrieves the vector for the word \"cheese\".\n",
        "\n",
        "Your task is to calculate how similar the word \"cheese\" (or any other word you choose) is to a list of other words (given below) using cosine similarity. \n"
      ],
      "id": "02ff9431"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "potential_words = [\"elephant\", \"cheese\", \"butter\", \"bread\", \"watermelon\", \"potato\", \"iron\", \"clock\", \"computer\", \"chicken\", \"fries\"]"
      ],
      "id": "133855d6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Return a sorted dictionary where keys are words and values are their cosine similarity to \"cheese\".\n",
        "\n",
        "You can **AFTERWARDS** also use the built-in method to find most similar words:"
      ],
      "id": "b5ccde47"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "model.most_similar(\"cheese\", topn=10)"
      ],
      "id": "5c86fcbc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Bonus:** Play around with vector arithmetic to explore relationships - you can add and subtract word vectors to see how meanings combine. For example, try \"king\" - \"man\" + \"woman\" and see what word is closest to the resulting vector! Or try \"Paris\" - \"France\" + \"Armenia\" to see if you get \"Yerevan\".\n",
        "\n",
        "::: {.callout-note collapse=\"true\" appearance=\"minimal\"}\n",
        " Check out this fantastic [3Blue1Brown video on word vectors (embeddings)](https://youtu.be/wjZofJX0v4M?t=751) for more insights! Also, [this](https://huggingface.co/blog/embeddinggemma#demo) is a cool tool to play with\n",
        ":::\n",
        "\n",
        "\n",
        "## Vector Spaces and Subspaces\n",
        "### 09: Identifying vector spaces and non-vector spaces {data-difficulty=\"3\"}\n",
        "\n",
        "For each of the following sets, determine whether it is a vector space or not. If it is a vector space, prove it by verifying all the required axioms. If it is not a vector space, identify which axiom(s) fail and provide counterexamples. \n",
        "\n",
        "a) $A = \\left\\{\\begin{pmatrix} a \\\\ 0 \\end{pmatrix} \\mid a \\in \\mathbb{R}\\right\\}$ (vectors with second component zero)\n",
        "\n",
        "b) $B = \\left\\{\\begin{pmatrix} a \\\\ -a \\end{pmatrix} \\mid a \\in \\mathbb{R}\\right\\}$ (vectors where second component is negative of first)\n",
        "\n",
        "c) $C = \\mathbb{N}$ (the set of natural numbers)\n",
        "\n",
        "d) $D = \\left\\{\\begin{pmatrix} a \\\\ 1 \\end{pmatrix} \\mid a \\in \\mathbb{R}\\right\\}$ (vectors with second component always 1)\n",
        "\n",
        "Note: By default, if we don't mention the operation, we mean the standard vector addition and scalar multiplication (e.g. our good old + and * we learning at school).\n",
        "\n",
        "**Hint:** For the non-vector spaces, show that there are some \"bad\" elements such that if we add them or multiply with some number (not necessarily positive), the result would not belong to the set.\n",
        "\n",
        "### 10 vector space or not? {data-difficulty=\"2\"}\n",
        "\n",
        "Check if the following set is a vector space:\n",
        "\n",
        "a) $A=\\mathbb{Z}$, with the usual operations $+$ and $\\cdot$.\n",
        "\n",
        "b) $B=\\left\\{ \\begin{bmatrix} 0 \\\\ 0 \\\\ a \\end{bmatrix} \\,\\middle|\\, a\\in\\mathbb{R} \\right\\}$ with the usual operations $+$ and $\\cdot$.\n",
        "\n",
        "c) $C=\\mathbb{R}^2=\\left\\{ \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\,\\middle|\\, a,b\\in\\mathbb{R} \\right\\}$, with the usual operation $\\cdot$ and the addition defined as\n",
        "$$\n",
        "\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix}\n",
        "+\n",
        "\\begin{bmatrix} y_1 \\\\ y_2 \\end{bmatrix}\n",
        "=\n",
        "\\begin{bmatrix} x_1 + y_1 \\\\ x_2 + y_2 + 1 \\end{bmatrix}.\n",
        "$$\n",
        "\n",
        "d) The set of all polynomials of degree $\\le 2$, with the usual operations $+$ and $\\cdot$. Bonus question - is this maybe \"equivalent\" to some other vector space we already know?\n",
        "\n",
        "\n",
        "\n",
        "### 11 Vector subspaces {data-difficulty=\"2\"}\n",
        "![](assets/subspace_exercise.png)\n",
        "\n",
        "[Video](https://www.youtube.com/watch?v=N8GR7eCepl8) solution\n",
        "\n",
        "\n",
        "### 12 Deriving the cosine angle formula {.bonus problem data-difficulty=\"3\"}\n",
        "\n",
        "Derive the formula for the cosine of the angle between two vectors: $\\cos(\\theta) = \\frac{\\vec{a} \\cdot \\vec{b}}{||\\vec{a}|| \\cdot ||\\vec{b}||}$\n",
        "\n",
        "::: {.callout-warning collapse=\"true\" appearance=\"minimal\"}\n",
        "#### Hint\n",
        "Start with the law of cosines for a triangle: $c^2 = a^2 + b^2 - 2ab\\cos(\\theta)$. Consider a triangle formed by vectors $\\vec{a}$, $\\vec{b}$, and $\\vec{a} - \\vec{b}$. The side lengths are $||\\vec{a}||$, $||\\vec{b}||$, and $||\\vec{a} - \\vec{b}||$. Express $||\\vec{a} - \\vec{b}||^2$ using the dot product and substitute into the law of cosines.\n",
        ":::\n",
        "\n",
        "1. Write down the law of cosines for the triangle with sides $||\\vec{a}||$, $||\\vec{b}||$, and $||\\vec{a} - \\vec{b}||$\n",
        "2. Express $||\\vec{a} - \\vec{b}||^2$ in terms of dot products by expanding $(\\vec{a} - \\vec{b}) \\cdot (\\vec{a} - \\vec{b})$\n",
        "3. Substitute your result from part (2) into the law of cosines and solve for $\\cos(\\theta)$\n",
        "4. Verify your derived formula using vectors $\\vec{u} = (3, 4)$ and $\\vec{v} = (1, 0)$\n",
        "\n",
        "\n",
        "### 13 High-dimensional vector geometry {.bonus-problem data-difficulty=\"1\"}\n",
        "In high-dimensional spaces (common in ML), our intuition about geometry can be misleading (we will explore this later).\n",
        "\n",
        "Consider the unit sphere in $\\mathbb{R}^n$ (all vectors with norm 1):\n",
        "\n",
        "1. In 2D, what fraction of a unit square $[-1,1] \\times [-1,1]$ is occupied by the unit circle?\n",
        "2. Estimate this fraction for a unit cube in 3D (you can google the formula)\n",
        "3. Try to guess and then google  What happens to this fraction as the dimension $n$ increases? This is known as the \"curse of dimensionality.\"\n",
        "\n",
        "[Video](https://www.youtube.com/watch?v=9Tf-_mJhOkU)\n",
        "\n",
        "# üé≤ 38 (01) TODO\n",
        "- ‚ñ∂Ô∏è[ToDo]()\n",
        "- üîó[Random link]()\n",
        "- üá¶üá≤üé∂[ToDo]()\n",
        "- üåêüé∂[ToDo]()\n",
        "- ü§å[‘ø’°÷Ä’£’´’∂]()\n",
        "\n",
        "\n",
        "<a href=\"http://s01.flagcounter.com/more/1oO\"><img src=\"https://s01.flagcounter.com/count2/1oO/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_10/viewers_0/labels_0/pageviews_1/flags_0/percent_0/\" alt=\"Flag Counter\"></a>\n"
      ],
      "id": "30befdd4"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\hayk_\\AppData\\Local\\Programs\\Python\\Python310\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}